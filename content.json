[{"title":"iOS Animations 笔记","date":"2016-06-15T01:33:11.000Z","path":"Notes/iOS-Animations-笔记.html","text":"对iOS的动画相关的方面单独做了一下整理，以后有时间会持续更新… View 动画123456789UIView.animateWithDuration(0.5, animations: &#123; self.heading.center.x += self.view.bounds.width&#125;)UIView.animateWithDuration(0.5, delay: 0.3, options: [], animations: &#123; self.username.center.x += self.view.bounds.width&#125;, completion: nil)UIView.animateWithDuration(0.5, delay: 0.4, options: [], animations: &#123; self.password.center.x += self.view.bounds.width&#125;, completion: nil) 可做动画的属性Position and size bounds frame center Appearance backgroundColor alpha ###Transformation transform 动画 optionsRepeating .Repeat 使你的动画永远循环重复 .Autoreverse 这个选项只能和 .Repeat 一起使用，正向反向的重复动画 123UIView.animateWithDuration(0.5, delay: 0.4, options: [.Repeat, .Autoreverse], animations: &#123; self.password.center.x += self.view.bounds.width &#125;, completion: nil) Easing .Linear :线性 .CurveEaseIn : 动画开始时，加速 .CurveEaseOut : 动画结束时，减速 .CurveEaseInOut : 动画开始时，加速，并且，动画结束时，减速 123UIView.animateWithDuration(0.5, delay: 0.4, options: [.Repeat, .Autoreverse, .CurveEaseOut], animations: &#123; self.password.center.x += self.view.bounds.width &#125;, completion: nil) Springs usingSpringWithDamping : 弹簧动画的阻尼值，也就是相当于摩擦力的大小，该属性的值从0.0到1.0之间，越靠近0，阻尼越小，弹动的幅度越大，反之阻尼越大，弹动的幅度越小，如果大道一定程度，会出现弹不动的情况。 initialSpringVelocity : 弹簧动画的速率，或者说是动力。值越小弹簧的动力越小，弹簧拉伸的幅度越小，反之动力越大，弹簧拉伸的幅度越大。这里需要注意的是，如果设置为0，表示忽略该属性，由动画持续时间和阻尼计算动画的效果。 1234UIView.animateWithDuration(0.5, delay: 0.5, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.0, options: [], animations: &#123; self.loginButton.center.y -= 30.0 self.loginButton.alpha = 1.0 &#125;, completion: nil) TransitionsOptions .TransitionFlipFromLeft .TransitionFlipFromRight .TransitionCurlUp .TransitionCurlDown .TransitionCrossDissolve .TransitionFlipFromTop .TransitionFlipFromBottom 123456789//添加一个新 view，需要更改 view 的层次，transition 需要 container viewUIView.transitionWithView(animationContainerView!, duration: 0.33, options: [.CurveEaseOut, .TransitionFlipFromBottom], animations: &#123; self.animationContainerView!.addSubview(newView) &#125;, completion: nil) //remove the view via transitionUIView.transitionWithView(animationContainerView!, duration: 0.33, doptions: [.CurveEaseOut, .TransitionFlipFromBottom], animations: &#123; self.newView.removeFromSuperview() &#125;, completion: nil) 12345//显示隐藏 view，无需更改 view 的层次，transition 无需 container view//hide the view via transitionUIView.transitionWithView(self.newView, duration: 0.33, options: [.CurveEaseOut, .TransitionFlipFromBottom], animations: &#123; self.newView.hidden = true &#125;, completion: nil) 1234//替换 view//replace via transitionUIView.transitionFromView(self.oldView!, toView: self.newView!, duration: 0.33, options: [.TransitionFlipFromTop],completion: nil) 关键帧动画123456789101112131415161718192021222324252627282930313233343536let originalCenter = planeImage.centerUIView.animateKeyframesWithDuration(1.5, delay: 0.0, options: [], animations: &#123; //add keyframes UIView.addKeyframeWithRelativeStartTime(0.0, relativeDuration: 0.25, animations: &#123; self.planeImage.center.x += 80.0 self.planeImage.center.y -= 10.0 &#125;) UIView.addKeyframeWithRelativeStartTime(0.1, relativeDuration: 0.4) &#123; self.planeImage.transform = CGAffineTransformMakeRotation(CGFloat(-M_PI_4/2)) &#125; UIView.addKeyframeWithRelativeStartTime(0.25, relativeDuration: 0.25) &#123; self.planeImage.center.x += 100.0 self.planeImage.center.y -= 50.0 self.planeImage.alpha = 0.0 &#125; UIView.addKeyframeWithRelativeStartTime(0.51, relativeDuration: 0.01) &#123; self.planeImage.transform = CGAffineTransformIdentity self.planeImage.center = CGPoint(x: 0.0, y: originalCenter.y) &#125; UIView.addKeyframeWithRelativeStartTime(0.55, relativeDuration: 0.45) &#123; self.planeImage.alpha = 1.0 self.planeImage.center = originalCenter &#125; &#125;, completion: nil) Auto Layout123456789101112131415161718isMenuOpen = !isMenuOpen for constraint in titleLabel.superview!.constraints &#123; //循环约束，找出相应的所需的约束 if constraint.firstItem as? NSObject == titleLabel &amp;&amp; constraint.firstAttribute == .CenterX &#123; constraint.constant = isMenuOpen ? -100.0 : 0.0 continue &#125;&#125;//menuHeightConstraint 为 Menu 的 高度约束menuHeightConstraint.constant = isMenuOpen ? 200.0 : 60.0titleLabel.text = isMenuOpen ? \"Select Item\" : \"Packing List\" UIView.animateWithDuration(1.0, delay: 0.0, usingSpringWithDamping: 0.4, initialSpringVelocity: 10.0, options: .CurveEaseIn, animations: &#123; //调用 layoutIfNeeded 更新约束，更新布局，产生动画 self.view.layoutIfNeeded() &#125;, completion: nil) 属性 constant 是 NSLayoutConstraint 类中仅有的可变的属性（mutable property），若要修改 multiplier 或修改为另一个约束，则需要删除这个约束再增加一个新的约束（replace） 123456789101112131415161718192021222324252627282930313233343536isMenuOpen = !isMenuOpen for constraint in titleLabel.superview!.constraints &#123; if constraint.firstItem as? NSObject == titleLabel &amp;&amp; constraint.firstAttribute == .CenterX &#123; constraint.constant = isMenuOpen ? -100.0 : 0.0 continue &#125; //通过标识符找到对应所需的约束 if constraint.identifier == \"TitleCenterY\" &#123; //通过将约束的 active 设为 false 来删除此约束，如果没有引用指向这个约束，这个约束对象将从内存中删除 constraint.active = false //add new constraint let newConstraint = NSLayoutConstraint( item: titleLabel, attribute: .CenterY, relatedBy: .Equal, toItem: titleLabel.superview!, attribute: .CenterY, multiplier: isMenuOpen ? 0.67 : 1.0, constant: 5.0) newConstraint.identifier = \"TitleCenterY\" //通过设置 newConstraint 的属性 active 为 true，来通知 Auto Layout 应用新的约束(newConstraint) newConstraint.active = true continue &#125;&#125;menuHeightConstraint.constant = isMenuOpen ? 200.0 : 60.0titleLabel.text = isMenuOpen ? \"Select Item\" : \"Packing List\" UIView.animateWithDuration(1.0, delay: 0.0, usingSpringWithDamping: 0.4, initialSpringVelocity: 10.0, options: .CurveEaseIn, animations: &#123; self.view.layoutIfNeeded() &#125;, completion: nil) 1234567891011121314151617181920212223242526272829303132333435func showItem(index: Int) &#123; print(\"tapped item \\(index)\") let imageView = UIImageView(image: UIImage(named: \"summericons_100px_0\\(index).png\")) imageView.backgroundColor = UIColor(red: 0.0, green: 0.0, blue: 0.0, alpha: 0.5) imageView.layer.cornerRadius = 5.0 imageView.layer.masksToBounds = true imageView.translatesAutoresizingMaskIntoConstraints = false view.addSubview(imageView) //iOS 9.0 之后，约束的新用法 let conX = imageView.centerXAnchor.constraintEqualToAnchor( view.centerXAnchor) let conBottom = imageView.bottomAnchor.constraintEqualToAnchor( view.bottomAnchor, constant: imageView.frame.height) let conWidth = imageView.widthAnchor.constraintEqualToAnchor( view.widthAnchor,multiplier: 0.33,constant: -50.0) let conHeight = imageView.heightAnchor.constraintEqualToAnchor( imageView.widthAnchor) NSLayoutConstraint.activateConstraints([conX, conBottom, conWidth, conHeight]) //使约束生效，作为后面动画的初始状态，这样后面的动画才会正常 view.layoutIfNeeded() UIView.animateWithDuration(0.8, delay: 0.0, usingSpringWithDamping: 0.4, initialSpringVelocity: 0.0, options: [], animations: &#123; conBottom.constant = -imageView.frame.size.height/2 conWidth.constant = 0.0 self.view.layoutIfNeeded() &#125;, completion: nil) UIView.animateWithDuration(0.8, delay: 1.0,usingSpringWithDamping: 0.4, initialSpringVelocity: 0.0,options: [], animations: &#123; conBottom.constant = imageView.frame.size.height conWidth.constant = -50.0 self.view.layoutIfNeeded() &#125;, completion: &#123;_ in imageView.removeFromSuperview() &#125;) &#125; Layer 动画能用 View 动画时就用 View 动画，但当需要更多性能与灵活性是，可以考虑用 Layer 动画 Views Layers 复杂的View层次布局，Auto Layout 等 简单的层次，更快的布局，更快的绘制 用户交互 没有响应事件链的开销 经常在CPU主线程上执行自定义逻辑和自定义绘制代码 默认没有自定义逻辑。经常有缓存，在GPU上直接绘制 非常灵活，强大，有很多子类 不灵活，很少子类 可做动画的属性Position and size bounds position transform Border borderColor borderWidth cornerRadius Shadow shadowOffset shadowOpacity shadowPath shadowRadius Contents contents mask opacity 以上可动画的属性只是一部分，CALayer的子类另外也有很多可动画的属性 123456789101112//CABasicAnimation 只是一个数据模型，没有局限于具体的 layerlet flyRight = CABasicAnimation(keyPath: \"position.x\")flyRight.fromValue = -view.bounds.size.width/2flyRight.toValue = view.bounds.size.width/2flyRight.duration = 0.5heading.layer.addAnimation(flyRight, forKey: nil)flyRight.beginTime = CACurrentMediaTime() + 0.3//可以重用动画 flyRight 在其他 layer 上，每个 layer 都将独立运行该动画的一个副本//addAnimation(_:forKey:) 会创建一个动画对象的副本username.layer.addAnimation(flyRight, forKey: nil) fillMode","tags":[{"name":"iOS","slug":"iOS","permalink":"https://coderdotcool.github.io/tags/iOS/"},{"name":"Animations","slug":"Animations","permalink":"https://coderdotcool.github.io/tags/Animations/"},{"name":"Swift","slug":"Swift","permalink":"https://coderdotcool.github.io/tags/Swift/"}]},{"title":"Swift笔记","date":"2016-05-19T12:22:07.000Z","path":"Notes/Swift笔记.html","text":"闲暇学习Swift记的笔记，后有时间会持续更新，查漏补缺…😀 基本常量1let pi: Double = 3.14159 变量12var variableNumber: Int = 42variableNumber = 1_000_000 命名12//You can even use the full range of Unicode charactersvar 变量ßœ√å: Int = -1 类型推导12let coordinates3D: (x: Int, y: Int, z: Int) = (2, 3, 1)let (x, y, z) = coordinates3D 类型转换1234567var integer: Int = 100var decimal: Double = 12.5integer = Int(decimal)let hourlyRate = 19.5let hoursWorked = 10let totalCost = hourlyRate * Double(hoursWorked) 元组(Tuples)12345678910let coordinates: (Int, Int) = (2, 3)let x: Int = coordinates.0let y: Int = coordinates.1let coordinates3D: (x: Int, y: Int, z: Int) = (2, 3, 1)let x1 = coordinates3D.xlet y1 = coordinates3D.ylet z1 = coordinates3D.zlet (x2, y2, _) = coordinates3D 取模12let moduloDecimal = 11.6 % 1.2//moduloDecimal 等于 0.8，因为11.6 = 1.2*9+0.8 Shift operations123let shiftLeft = 1 &lt;&lt; 3let shiftRight = 32 &gt;&gt; 2//结果都等于 8 字符串12345678910111213141516let name = \"Matt\"let message = \"Hello my name is \\(name)!\" // \"Hello my name is Matt!\"let oneThird = 1.0 / 3.0let oneThirdLongString = \"One third is \\(oneThird) as a decimal.\" //One third is 0.3333333333333333 as a decimal.//combining characterlet stringA = \"café\"let stringB = \"cafe\\u&#123;0301&#125;\"stringA.characters.count //4stringB.characters.count //4let equal = stringA == stringB //equal 为 truelet string = \"Swift Apprentice is a great book!\"string.uppercaseString //SWIFT APPRENTICE IS A GREAT BOOK!string.lowercaseString //swift apprentice is a great book! 判断if1234567891011var hoursWorked = 45var price = 0if hoursWorked &gt; 40 &#123; let hoursOver40 = hoursWorked - 40 price += hoursOver40 * 50 hoursWorked -= hoursOver40&#125;price += hoursWorked * 25print(price)//1250 switch12345678910111213141516171819let hourOfDay = 12let timeOfDay: Stringswitch (hourOfDay) &#123;case 0, 1, 2, 3, 4, 5: timeOfDay = \"Early morning\"case 6, 7, 8, 9, 10, 11:timeOfDay = \"Morning\"case 12, 13, 14, 15, 16: timeOfDay = \"Afternoon\"case 17, 18, 19: timeOfDay = \"Evening\"case 20, 21, 22, 23: timeOfDay = \"Late evening\"default: timeOfDay = \"INVALID HOUR!\"&#125;print(timeOfDay)//Afternoon 123456789let number = 10switch (number) &#123;case let x where x % 2 == 0: print(\"Even\")default: print(\"Odd\")&#125;//Even 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748let coordinates: (x: Int, y: Int, z: Int) = (3, 2, 5)switch (coordinates) &#123;case (0, 0, 0): // 1 print(\"Origin\")case (_, 0, 0): // 2 print(\"On the x-axis.\")case (0, _, 0): // 3 print(\"On the y-axis.\")case (0, 0, _): // 4 print(\"On the z-axis.\")default: // 5 print(\"Somewhere in space\")&#125;switch (coordinates) &#123;case (let x, let y, let z) where x == y &amp;&amp; y == z: print(\"x = y = z\")case (_, _, 0): print(\"On the x/y plane\")case (_, 0, _): print(\"On the x/z plane\")case (0, _, _): print(\"On the y/z plane\")default: print(\"Nothing special\")&#125;switch (coordinates) &#123;case (0, 0, 0): print(\"Origin\")case (let x, 0, 0): print(\"On the x-axis at x = \\(x)\")case (0, let y, 0): print(\"On the y-axis at y = \\(y)\")case (0, 0, let z): print(\"On the z-axis at z = \\(z)\")case (let x, let y, let z): print(\"Somewhere in space at x = \\(x), y = \\(y), z = \\(z)\")&#125;switch (coordinates) &#123;case (let x, let y, _) where y == x: print(\"Along the y = x line.\")case (let x, let y, _) where y == x * x: print(\"Along the y = x^2 line.\")default:break&#125; Ranges12let closedRange = 0...5let halfOpenRange = 0..&lt;5 12345678910111213141516let hourOfDay = 12let timeOfDay: Stringswitch (hourOfDay) &#123;case 0...5: timeOfDay = \"Early morning\"case 6...11: timeOfDay = \"Morning\"case 12...16: timeOfDay = \"Afternoon\"case 17...19: timeOfDay = \"Evening\"case 20..&lt;24: timeOfDay = \"Late evening\"default: timeOfDay = \"INVALID HOUR!\"&#125; 循环for12345let count = 10var sum = 0for i in 1...count &#123; sum += i &#125; 12345678let count = 10var sum = 1var lastSum = 0for _ in 0..&lt;count &#123; let temp = sum sum = sum + lastSum lastSum = temp&#125; while1234var sum = 1while sum &lt; 1000 &#123; sum = sum + (sum + 1)&#125; repeat1234var sum = 1repeat &#123; sum = sum + (sum + 1)&#125; while sum &lt; 1000 labeled statements123456789var sum = 0rowLoop: for row in 0..&lt;8 &#123; columnLoop: for column in 0..&lt;8 &#123; if row == column &#123; continue rowLoop &#125; sum += row * column &#125;&#125; 函数参数1234func printMyName() &#123; print(\"My name is Matt Galloway.\")&#125;printMyName() 1234func printMultipleOf(multiplier: Int, and andValue: Int) &#123; print(\"\\(multiplier) * \\(andValue) = \\(multiplier * andValue)\")&#125;printMultipleOf(4, and: 2) 1234func printMultipleOf(multiplier: Int, _ andValue: Int) &#123; print(\"\\(multiplier) * \\(andValue) = \\(multiplier * andValue)\")&#125;printMultipleOf(4, 2) 1234func printMultipleOf(multiplier: Int, and andValue: Int = 1) &#123; print(\"\\(multiplier) * \\(andValue) = \\(multiplier * andValue)\")&#125;printMultipleOf(4) 返回值1234func multiply(number: Int, by byValue: Int) -&gt; Int &#123; return number * byValue&#125;let result = multiply(4, by: 2) 1234567func multiplyAndDivide(number: Int, by byValue: Int) -&gt; (multiply: Int,divide: Int) &#123; return (number * byValue, number / byValue)&#125;let result = multiplyAndDivide(4, by: 2)let multiply = result.multiplylet divide = result.divide 默认pass-by-value函数参数与用let声明的常量等价. 12345func incrementAndPrint(value: Int) &#123; value += 1 print(value)&#125;//Error : Left side of mutating operator isn't mutable: 'value' is a 'let' constant pass-by-reference12345678910func incrementAndPrintInOut(inout value: Int) &#123; value += 1 print(value)&#125;var value = 5incrementAndPrintInOut(&amp;value)print(value)// 6 // 6 函数作为变量123456789101112func add(a: Int, _ b: Int) -&gt; Int &#123; return a + b &#125;var function: (Int, Int) -&gt; Int = addfunc printResult(function: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123; let result = function(a, b) print(result)&#125;printResult(add, 4, 2)//6 ClosureA closure is simply a function with no name. 匿名函数 1234567var multiplyClosure: (Int, Int) -&gt; IntmultiplyClosure = &#123; (a: Int, b: Int) -&gt; Int in return a * b &#125;let result = multiplyClosure(4, 2)//8 简写123456789101112131415161718192021var multiplyClosure: (Int, Int) -&gt; Int//可以省掉returnmultiplyClosure = &#123; (a: Int, b: Int) -&gt; Int in a*b &#125;//可以省掉返回类型multiplyClosure = &#123; (a: Int, b: Int) in a*b &#125;//可以省掉参数类型multiplyClosure = &#123; (a, b) in a*b &#125;//可以省掉参数列表multiplyClosure = &#123; $0 * $1 &#125; 123456789101112131415161718192021222324252627282930313233func operateOnNumbers(a: Int, _ b: Int, operation: (Int, Int) -&gt; Int) -&gt; Int &#123; let result = operation(a, b) print(result) return result&#125;//1let addClosure = &#123; (a: Int, b: Int) in a+b &#125;operateOnNumbers(4, 2, operation: addClosure)//2func addFunction(a: Int, b: Int) -&gt; Int &#123; return a + b &#125;operateOnNumbers(4, 2, operation: addFunction)//3operateOnNumbers(4, 2, operation: &#123; (a: Int, b: Int) -&gt; Int in return a + b &#125;)//4operateOnNumbers(4, 2, operation: &#123; $0 + $1 &#125;)//最终可简写为：operateOnNumbers(4, 2) &#123; $0 + $1 &#125; 无返回值1234let voidClosure: () -&gt; Void = &#123; print(\"Swift is awesome!\")&#125;voidClosure() 闭包1234567891011121314151617func countingClosure() -&gt; (() -&gt; Int) &#123; var counter = 0 let incrementCounter: () -&gt; Int = &#123; counter += 1 return counter &#125; return incrementCounter&#125;let counter1 = countingClosure()let counter2 = countingClosure()counter1() // 0counter2() // 0counter1() // 1counter1() // 2counter2() // 1 Optionalsforce unwrapping12345var authorName: String? = \"Matt Galloway\"var unwrappedAuthorName = authorName!print(\"Author is \\(unwrappedAuthorName)\")//Author is Matt Galloway If let binding12345678let authorName: String? = \"Matt Galloway\"let authorAge: Int? = 30if let name: String = authorName, age: Int = authorAge &#123; print(\"The author is \\(name) who is \\(age) years old.\")&#125; else &#123; print(\"No author or no age.\")&#125; nil coalescing123456789101112var optionalInt: Int? = 10//result = optionalInt ？optionalInt : 0var result: Int = optionalInt ?? 0//等价于：var optionalInt: Int? = 10var result: Intif let unwrapped = optionalInt &#123; result = unwrapped&#125; else &#123; result = 0 &#125; 集合数组创建数组12345678let numbers: Array&lt;Int&gt;let inferredNumbers = Array&lt;Int&gt;()let alsoInferredNumbers = [Int]()let evenNumbers = [2, 4, 6, 8]let allZeros = [Int](count: 5, repeatedValue: 0) //[0, 0, 0, 0, 0] 属性和方法1234567891011121314151617181920212223242526272829303132333435363738var players = [\"Alice\", \"Bob\", \"Cindy\", \"Dan\"]print(players.isEmpty)// &gt; falsevar currentPlayer = players.firstprint(currentPlayer)// &gt; Optional(\"Alice\")print(players.last)// &gt; Optional(\"Dan\")currentPlayer = players.minElement()print(currentPlayer)// &gt; Optional(\"Alice\")if let currentPlayer = currentPlayer &#123; print(\"\\(currentPlayer) will start\")&#125;// &gt; Alice will startprint([2, 3, 1].first)// &gt; Optional(2)print([2, 3, 1].minElement())// &gt; Optional(1)print([2, 3, 1].maxElement())// &gt; Optional(3)var firstPlayer = players[0]print(\"First player is \\(firstPlayer)\")// &gt; First player is \"Alice\"//用 Rangelet upcomingPlayers = players[1...2]print(upcomingPlayers)// &gt; [\"Bob\", \"Cindy\"]players[1...3].contains(\"Bob\")// &gt; true 数组操作123456789101112131415161718192021222324252627282930313233343536373839//追加var players = [\"Alice\", \"Bob\", \"Cindy\", \"Dan\"]players.append(\"Eli\")players += [\"Gina\"] print(players)// &gt; [\"Alice\", \"Bob\", \"Cindy\", \"Dan\", \"Eli\", \"Gi//插入players.insert(\"Frank\", atIndex: 5)//删除var removedPlayer = players.removeLast()print(\"\\(removedPlayer) was removed\")// &gt; Gina was removedremovedPlayer = players.removeAtIndex(2)print(\"\\(removedPlayer) was removed\")// &gt; Cindy was removed//更新print(players)// &gt; [\"Alice\", \"Bob\", \"Dan\", \"Eli\", \"Frank\"]players[4] = \"Franklin\"print(players)// &gt; [\"Alice\", \"Bob\", \"Dan\", \"Eli\", \"Franklin\"]players[0...1] = [\"Donna\", \"Craig\", \"Brian\", \"Anna\"]print(players)// &gt; [\"Donna\", \"Craig\", \"Brian\", \"Anna\", \"Dan\", \"Eli\", \"Franklin\"]//移动let playerAnna = players.removeAtIndex(3)players.insert(playerAnna, atIndex: 0)print(players)// &gt; [\"Anna\", \"Donna\", \"Craig\", \"Brian\", \"Dan\", \"Eli\", \"Franklin\"]players = players.sort()print(players)// &gt; [\"Anna\", \"Brian\", \"Craig\", \"Dan\", \"Donna\", \"Eli\", \"Franklin\"] 遍历123456789101112131415161718var players = [\"Alice\", \"Bob\", \"Cindy\", \"Dan\"]for playerName in players &#123; print(playerName)&#125;// &gt; Anna// &gt; Bob// &gt; Cindy// &gt; Danfor (index, playerName) in players.enumerate() &#123; print(\"\\(index + 1). \\(playerName)\")&#125;// &gt; 1. Anna// &gt; 2. Bob// &gt; 3. Cindy// &gt; 4. Dan Sequence operations1234567891011121314151617181920let scores = [2, 2, 8, 6, 1, 2]//reduce//用第一个参数作为初始值，用combile操作符累计数组(scores)元素let sum = scores.reduce(0, combine: +)print(sum)// &gt; 21//filter//接受一个closure作为参数，对数组(scores)每个元素执行此closure，若此closure返回true，则将对应的元素添加到返回数组中print(scores.filter(&#123; $0 &gt; 5 &#125;))// &gt; [8, 6]//map//接受一个closure作为参数,对数组(scores)每个元素执行此closure，返回一个新的元素并将之添加到返回数组中print(scores)// &gt; [2, 2, 8, 6, 1, 2]let newScores = scores.map(&#123; $0 * 2 &#125;)print(newScores)// &gt; [4, 4, 16, 12, 2, 4] 字典创建字典123456789101112let pairs: Dictionary&lt;String, Int&gt;let inferredPairs = Dictionary&lt;String, Int&gt;()let alsoInferredPairs = [String: Int]()let namesAndScores = [\"Anna\": 2, \"Brian\": 2, \"Craig\": 8, \"Donna\": 6]print(namesAndScores)// &gt; [\"Brian\": 2, \"Anna\": 2, \"Craig\": 8, \"Donna\": 6]var emptyDictionary: [Int: Int]emptyDictionar = [:] 属性和方法1234567891011121314151617let namesAndScores = [\"Anna\": 2, \"Brian\": 2, \"Craig\": 8, \"Donna\": 6]print(namesAndScores[\"Anna\"])// &gt; Optional(2)print(namesAndScores[\"Greg\"])// &gt; nilprint(namesAndScores.isEmpty)// &gt; falseprint(namesAndScores.count)// &gt; 4print(Array(namesAndScores.keys))// &gt; [\"Brian\", \"Anna\", \"Craig\", \"Donna\"]print(Array(namesAndScores.values))// &gt; [2, 2, 8, 6] 字典操作123456789var bobData = [\"name\": \"Bob\", \"profession\": \"Card Player\", \"country\": \"USA\"]//更新bobData.updateValue(\"CA\", forKey: \"state\")bobData[\"city\"] = \"San Francisco\"//删除bobData.removeValueForKey(\"state\")bobData[\"city\"] = nil 遍历123456789101112131415let namesAndScores = [\"Anna\": 2, \"Brian\": 2, \"Craig\": 8, \"Donna\": 6]for (key, value) in namesAndScores &#123; print(\"\\(key) - \\(value)\")&#125;// &gt; Brian - 2// &gt; Anna - 2// &gt; Craig - 8// &gt; Donna - 6for key in namesAndScores.keys &#123; print(\"\\(key), \", terminator: \"\") // no newline&#125;print(\"\") // print one final newline// &gt; Brian, Anna, Craig, Donna, Sequence operations123456789101112let namesAndScores = [\"Anna\": 2, \"Brian\": 2, \"Craig\": 8, \"Donna\": 6]//reduce//第一个参数为\"\"，用combile closure累计(前面字符串加上后面字典键值字符串)字典(namesAndScores)元素(键值)let namesString = namesAndScores.reduce(\"\", combine: &#123; $0 + \"\\($1.0), \" &#125;)print(namesString)// &gt; Brian, Anna, Craig, Donna,//filter//接受一个closure作为参数，对字典(namesAndScores)每个元素执行此closure，取出字典 value 小于 5 的元素print(namesAndScores.filter(&#123; $0.1 &lt; 5 &#125;))// &gt; [(\"Brian\", 2), (\"Anna\", 2)] Sets创建Set1234567891011121314let setOne: Set&lt;Int&gt;let setTwo = Set&lt;Int&gt;() print(setTwo)// &gt; []//必须显式声明是Set，否则，则创建了数组let someSet: Set&lt;Int&gt; = [1, 2, 3, 1]//可以省略Set中的元素类型let anotherSet: Set = [1, 2, 3, 1] print(someSet)// &gt; [2, 3, 1] 属性和方法1234567891011121314let someSet: Set&lt;Int&gt; = [1, 2, 3, 1]print(someSet.isEmpty)// &gt; falseprint(someSet.count)// &gt; 3print(someSet.contains(1))// &gt; trueprint(someSet.contains(4))// &gt; falseprint(someSet.first)// &gt; Optional(2) Set操作123456789101112131415161718192021222324252627282930313233343536var myTimes: Set = [\"8am\", \"9am\", \"10am\"] //插入myTimes.insert(\"11am\")print(myTimes)// &gt; [\"9am\", \"8am\", \"11am\", \"10am\"]//删除let removedElement = myTimes.remove(\"8am\")print(removedElement)// &gt; Optional(\"8am\")print(myTimes)//&gt;[\"9am\", \"11am\", \"10am\"]let adamTimes: Set = [\"9am\", \"11am\", \"1pm\"]//并集 unionlet unionSet = myTimes.union(adamTimes)print(unionSet)// &gt; [\"9am\", \"11am\", \"10am\", \"1pm\"]//交集 intersectlet intersectSet = myTimes.intersect(adamTimes)print(intersectSet)// &gt; [\"9am\", \"11am\"]//差集 subtractlet subtractSet = myTimes.subtract(adamTimes)print(subtractSet)// &gt; [\"10am\"]//异或 Exclusive Orlet exclusiveOrSet = myTimes.exclusiveOr(adamTimes)print(exclusiveOrSet)// &gt; [\"10am\", \"1pm\"] 遍历1234567var myTimes: Set = [\"8am\", \"9am\", \"10am\"]for element in myTimes &#123; print(element)&#125;// &gt; 9am// &gt; 11am// &gt; 10am 自定义类型结构体结构体无处不存在，许多Swift标准类型都是结构体，比如，Array, Int, Float, Double, Bool, Dictionary, Set 和 String都是被定义为结构体。所以它们所有自己的方法和属性。 简单创建使用12345678910111213141516171819202122struct Location &#123; let latitude: Double let longitude: Double&#125;let pizzaLocation = Location(latitude: 44.9871, longitude: -93.2758) struct DeliveryRange &#123; var range: Double let center: Location&#125;//常量，不能修改属性值let storeLocation = Location(latitude: 44.9871, longitude: -93.2758)//常量，可以修改属性值var pizzaRange = DeliveryRange(range: 200, center: storeLocation) print(pizzaRange.range) // 200print(pizzaRange.center.latitude) // 44.9871pizzaRange.range = 250 自定义构造方法123456789101112131415struct Location &#123; let latitude: Double let longitude: Double // String in GPS format \"44.9871,-93.2758\" init(coordinateString: String) &#123; let crdSplit = coordinateString.characters.split(\",\") latitude = atof(String(crdSplit.first!)) longitude = atof(String(crdSplit.last!)) &#125; &#125;//一旦自定义构造方法，默认构造方法将无效//故，不能执行 Location(latitude: 44.9871, longitude: -93.2758)let coords = Location(coordinateString: \"44.9871,-93.2758\")print(coords.latitude) // 44.9871print(coords.longitude) // -93.2758 构造方法重载 1234567891011121314151617181920212223242526struct Order &#123; var toppings: [String] var size: String var crust: String init(toppings: [String], size: String, crust: String) &#123; self.toppings = toppings self.size = size self.crust = crust &#125; init(size: String, crust: String) &#123; self.toppings = [\"Cheese\"] self.size = size self.crust = crust &#125; init(special: String) &#123; self.size = \"Large\" self.crust = \"Regular\" if special == \"Veggie\" &#123; self.toppings = [\"Tomatoes\", \"Green Pepper\", \"Mushrooms\"] &#125; else if special == “Meat” &#123; self.toppings = [\"Sausage\", \"Pepperoni\", \"Ham\", \"Bacon\"] &#125; else &#123; self.toppings = [\"Cheese\"] &#125; &#125; &#125; 构造方法必须显式的给除了Option类型的所有属性赋值 1234567891011121314struct ClimateControl &#123; var temperature: Double var humidity: Double? init(temp: Double) &#123; temperature = temp &#125; init(temp: Double, hum: Double) &#123; temperature = temp humidity = hum &#125;&#125;let ecoMode = ClimateControl(temp: 75.0)let dryAndComfortable = ClimateControl(temp: 71.0, hum: 30.0) 默认值 123456struct ClimateControl &#123; var temperature: Double = 68.0 var humidity: Double?&#125;let defaultClimate = ClimateControl()print(defaultClimate.temperature) // 68.0 方法123456789101112struct DeliveryRange &#123; var range: Double let center: Location func isInRange(customer: Location) -&gt; Bool &#123; let difference = sqrt(pow((latitude - center.latitude), 2) + pow((longitude - center.longitude), 2)) return difference &lt; range &#125;&#125;let range = DeliveryRange(range: 150, center: Location(\"44.9871,-93.2758\"))let customer = Location(coordinateString: “44.9850,-93.2750”)range.isInRange(customer) // true! Extensions1234567891011121314151617struct Location &#123; let latitude: Double let longitude: Double // String in GPS format \"44.9871,-93.2758\" init(coordinateString: String) &#123; let crdSplit = coordinateString.characters.split(\",\") latitude = atof(String(crdSplit.first!)) longitude = atof(String(crdSplit.last!)) &#125; &#125;extension Location &#123; func isNorthernHemisphere() -&gt; Bool &#123; return latitude &gt; 0.0 &#125;&#125;let location = Location(coordinateString: \"44.9850,-93.2750\")location.isNorthernHemisphere() // true 123456extension String &#123; func evenOrOdd() -&gt; String &#123; return characters.count % 2 == 0 ? \"Even!\" : \"Odd!\" &#125;&#125;\"I'm odd\".evenOrOdd() // \"Odd!\" 结构体变量123456789101112var range1: DeliveryRange = DeliveryRange(range: 200, center: Location(“44.9871,-93.2758”))// 将 range1 赋值给 range2var range2: DeliveryRange = range1print(range1.range) // 200print(range2.range) // 200// 修改 range1 的 range 为 '100'range1.range = 100// range1 的 range 为 '100', 但是 range2 的 range 仍然为 '200'// 结构体是值类型,而非引用类型print(range1.range) // 100print(range2.range) // 200 类创建12345678910111213//类不像结构体，类没有提供默认构造方法，必须要写构造方法显式的给属性赋值。class Person &#123; var firstName: String var lastName: String init(firstName: String, lastName: String) &#123; self.firstName = firstName self.lastName = lastName &#125; func fullName() -&gt; String &#123; return \"\\(firstName) \\(lastName)\" &#125;&#125;let john = Person(firstName: \"Johnny\", lastName: \"Appleseed\") 结构体是不可变的值类型，类是可变的应用类型。类通常用来代表对象，结构体用来代表值 1234567891011121314151617181920212223struct Grade &#123; let letter: String let points: Double let credits: Double&#125;class Student &#123; var firstName: String var lastName: String var grades: [Grade] = [] init(firstName: String, lastName: String) &#123; self.firstName = firstName self.lastName = lastName &#125; func recordGrade(grade: Grade) &#123; grades.append(grade) &#125;&#125;let jane = Student(firstName: “Jane”, lastName: “Appleseed”)let history = Grade(letter: “B”, points: 9.0, credits: 3.0)let math = Grade(letter: “A”, points: 16.0, credits: 4.0)jane.recordGrade(history)jane.recordGrade(math) 访问控制 public : 可以访问当前模块及其他模块中的任何实体（通常用于Framework）。 internal: 可以访问当前模块中的其他任何实体，但是在模块外无法访问，这是所有实体的默认访问级别（通常在一个单目标Application中不需要自行设置访问级别）。 private: 只能访问当前源文件中的实体（注意, Swift中的private和其他语言不太一样，它是基于源文件的，作用范围是整个源文件，如果一个源文件中有两个类，那么一个类可以访问另外一个类的私有成员） 类成员的访问级别不能高于类的访问级别 (注意, 嵌套类型的访问级别也符合此条规则) 继承1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class Person &#123; var firstName: String var lastName: String init(firstName: String, lastName: String) &#123; self.firstName = firstName self.lastName = lastName &#125; //析构 deinit &#123; print(\"\\(firstName) \\(lastName) is being removed from memory!\") &#125;&#125;class Student: Person &#123; //weak 表示弱引用，可避免循环引用。若无 weak 修饰，都为强引用。 weak var partner: Student? var grades: [Grade] = [] func recordGrade(grade: Grade) &#123; grades.append(grade) &#125; //required 要求其子类不仅必须要实现此构造方法，而且当其子类调用super.init时，必须要用此构造方法 override required init(firstName: String, lastName: String) &#123; grades = [] super.init(firstName: firstName, lastName: lastName) &#125; convenience init(transfer: Student) &#123; //使用 convenience 关键字进行修饰的构造方法必须要调用 本类 的构造方法进行初始化 self.init(firstName: transfer.firstName, lastName: transfer.lastName) &#125;&#125;class StudentAthlete: Student &#123; var failedClasses: [Grade] = [] // 必须要实现，因为其父类的 required，否则编译器报错 override required init(firstName: String, lastName: String) &#123; self.sports = [] super.init(firstName: firstName, lastName: lastName) &#125; init(firstName: String, lastName: String, sports: [String]) &#123; self.sports = sports let passGrade = Grade(letter: \"P\", points: 0.0, credits: 0.0) //必须在初始化所有属性后调用super.init super.init(firstName: firstName, lastName: lastName) recordGrade(passGrade) &#125; //重写 override func recordGrade(grade: Grade) &#123; var newFailedClasses: [Grade] = [] for grade in grades &#123; if grade.letter == \"F\" &#123; newFailedClasses.append(grade) &#125; &#125; failedClasses = newFailedClasses super.recordGrade(grade) &#125; func athleteIsEligible() -&gt; Bool &#123; return failedClasses.count &lt; 3 &#125;&#125;//final 阻止继承或重写final class Student: Person &#123; //...&#125;// Build error!class StudentAthlete: Student &#123; //...&#125;class Student: Person &#123; final func recordGrade(grade: Grade) &#123; //... &#125; &#125;class StudentAthlete: Student &#123; // Build error! override func recordGrade(grade: Grade) &#123; //... &#125; &#125; Swift中的构造方法分为designated构造方法与convenience构造方法两类 designated构造方法也被称为指定构造方法，convenience构造方法也被称为方便构造方法。 designated构造方法不加任何修饰关键字，convenience构造方法需要使用convenience关键字进行修饰。 子类designated构造方法中必须调用父类的designated构造方法。 convenience构造方法中必须调用当前类的构造方法。 convenience构造方法归根结底要调用到designated构造方法。 枚举创建1234567891011121314151617181920212223242526272829303132333435enum Month &#123; case January case February case March case April case May case June case July case August case September case October case November case December&#125;//等价于enum Month &#123; case January, February, March, April, May, June, July, August, September, October, November, December&#125;//既然编译器已知晓类型，可省掉类型func schoolSemester(month: Month) -&gt; String &#123; switch month &#123; case .August, .September, .October, .November, .December: return \"Autumn\" case .January, .February, .March, .April, .May: return \"Spring\" default: return \"Not in the school year\" &#125;&#125;var month = Month.Aprilmonth = .SeptemberschoolSemester(month) // \"Autumn\" Raw values123456789101112131415161718192021222324252627282930313233enum Month: Int &#123; case January = 1, February = 2, March = 3, April = 4, May = 5, June = 6, July = 7, August = 8, September = 9, October = 10, November = 11, December = 12&#125;//等价于enum Month: Int &#123; case January = 1, February, March, April, May, June, July, August, September, October, November, December&#125;//访问 raw valuefunc monthsUntilWinterBreak(month: Month) -&gt; Int &#123; return Month.December.rawValue - month.rawValue&#125;monthsUntilWinterBreak(.April) // 8//用 raw value 初始化//Month(rawValue: 5) 返回 Option 类型，需要解包if let fifthMonth = Month(rawValue: 5) &#123; monthsUntilWinterBreak(fifthMonth) // 7&#125;//非递增的枚举enum Coin: Int &#123; case Penny = 1 case Nickel = 5 case Dime = 10 case Quarter = 25&#125;let coin = Coin.Quartercoin.rawValue // 25 Associated values 每个枚举 case 可以有0个或多个关联值（Associated values） 每个枚举 case的关联值都可以有自己的数据类型 可以像命名函数参数那样命名关联值 一个枚举不能同时有 Raw values 或 Associated values 12345678910111213141516171819202122232425262728293031323334var balance = 100enum WithdrawalResult &#123; case Success(Int) case Error(String)&#125;func withdraw(amount: Int) -&gt; WithdrawalResult &#123; if amount &lt;= balance &#123; balance -= amount return .Success(balance) &#125; else &#123; return .Error(\"Not enough money!\") &#125;&#125;let result = withdraw(99)switch result &#123;case let .Success(newBalance): print(\"Your new balance is: \\(newBalance)\")case let .Error(message): print(message)&#125;enum HTTPMethod &#123; case GET case POST(String)&#125;//枚举可以用作状态机(state machine)enum TrafficLight &#123; case Red, Yellow, Green&#125;let trafficLight = TrafficLight.Red OptionalsOptionals 就是枚举类型 123456789101112131415//不用 `？` 声明 Optional 类型let email: Optional&lt;String&gt; = .None //.None 表示为没有值 nillet website: Optional&lt;String&gt; = .Some(\"docoder.com\") //.Some 表示有值，为关联值(Associated values)switch website &#123;case .None: print(\"No value\")case let .Some(value): print(\"Got a value: \\(value)\")&#125;//&gt; Got a value: docoder.comlet optionalNil: Optional&lt;Int&gt; = .NoneoptionalNil == nil // trueoptionalNil == .None // true 属性 (Properties)存储属性123456789enum Type &#123; case Work, Family, Friend&#125;struct Contact &#123; var fullName: String let emailAddress: String var type: Type = .Friend //默认值为 .Friend&#125;//虽然有默认值，但默认自动生成的构造方法依然要对每个属性赋值，除非自定义构造方法。 计算属性12345678910111213141516171819struct TV &#123; var height: Double var width: Double // 计算属性 var diagonal: Int &#123; let aSquared = pow(height, 2) let bSquared = pow(width, 2) let cSquared = aSquared + bSquared let c = sqrt(cSquared) let rounded = round(c) return Int(rounded) &#125; &#125;var tv = TV(height: 53.93, width: 95.87)let size = tv.diagonal // 110tv.width = 53.93let diagonal = tv.diagonal // 76 Getter and setter123456789101112131415161718192021struct TV &#123; var height: Double var width: Double var diagonal: Int &#123; get &#123; return Int(round(sqrt(height * height + width * width))) &#125; set &#123; let ratioWidth: Double = 16 let ratioHeight: Double = 9 //newValue 关键字 为 set 方法传进的值 height = Double(newValue) * ratioHeight / sqrt(ratioWidth * ratioWidth + ratioHeight * ratioHeight) width = height * ratioWidth / ratioHeight &#125; &#125;&#125;tv.diagonal = 70let height = tv.height // 34.32...let width = tv.width // 61.01... Type properties (静态属性)用 static 修饰的属性为 Type properties，类型本身的属性，可以跨所有实例。 1234567891011struct Level &#123; static var highestLevel = 1 let id: Int var boss: String var unlocked: Bool&#125;// Error: you can't access a type property on an instancelet highestLevel = level3.highestLevel //不能用实例访问// 必须用类型名访问let highestLevel = Level.highestLevel // 1 单例声明单例要用引用类型的 class ,而不能用值类型的 struct ,否则不能修改其属性 12345678class GameManager &#123; // 用 let 修饰的 Type properties (static) 常量 来存储 这个单一实例 static let defaultManager = GameManager() var gameScore = 0 var saveState = 0 // private 修饰构造方法，使之不能访问，不能再构造其他实例 private init() &#123;&#125;&#125; Property observers12345678910111213141516171819202122232425262728293031323334struct Level &#123; static var highestLevel = 1 let id: Int var boss: String var unlocked: Bool &#123; //didSet，属性设值后调用 didSet &#123; if unlocked &amp;&amp; id &gt; Level.highestLevel &#123; Level.highestLevel = id &#125; &#125; &#125;&#125;class LightBulb &#123; static let maxCurrent = 40 var currentCurrent = 0 &#123; //用 didSet 限制属性的取值 didSet &#123; if currentCurrent &gt; LightBulb.maxCurrent &#123; print(\"Current too high, falling back to previous setting.\") //oldValue 关键字 为 didSet 提供的，可以访问设值之前的值 currentCurrent = oldValue &#125; &#125; &#125;&#125;var light = LightBulb()light.currentCurrent = 50var current = light.currentCurrent // 0light.currentCurrent = 40current = light.currentCurrent // 40 懒加载（Lazy properties）123456789101112131415161718192021class Circle &#123; //lazy 的修饰，使 pi 这个立即执行的 closure 没有进行实际计算，直到第一次被访问时才对其计算。 //lazy 属性必须为变量，即，用 var 修饰，而不能用 let 修饰 lazy var pi = &#123; return ((4.0 * atan(1.0 / 5.0)) - atan(1.0 / 239.0)) * 4.0 &#125;() //closure 后面有`()`,表示立即执行 var radius: Double = 0 var circumference: Double &#123; return pi * radius * 2 &#125; init (radius: Double) &#123; self.radius = radius &#125;&#125;let circle = Circle(radius: 5) // 实例化一个 Circle, 此时 pi 还没执行// pi 现在有值了let circumference = circle.circumference // 31.42 方法(Methods)Function 转为 Method123456789101112131415161718192021enum Month: Int &#123; case January = 1, February, March, April, May, June, July, August, September, October, November, December&#125;func monthsUntilWinterBreak(month: Month) -&gt; Int &#123; return Month.December.rawValue - month.rawValue&#125;//转换为：enum Month: Int &#123; case January = 1, February, March, April, May, June, July, August, September, October, November, December //枚举中的Method，比之前的 function 更合理 func monthsUntilWinterBreak() -&gt; Int &#123; return Month.December.rawValue - self.rawValue &#125;&#125;let month = Month.Octoberlet monthsLeft = month.monthsUntilWinterBreak() // 2 构造方法(Initializers)1234567891011121314151617181920212223242526272829303132333435enum Month: Int &#123; case January = 1, February, March, April, May, June, July, August, September, October, November, December //构造方法不需要 func 关键字和命名 init() &#123; self = .January &#125; func monthsUntilWinterBreak() -&gt; Int &#123; return Month.December.rawValue - self.rawValue &#125;&#125;let month = Month() // Januarylet monthsLeft = month.monthsUntilWinterBreak() // 11struct Date &#123; var month: Month var day: Int //自定义构造方法后，默认构造方法将无效 init() &#123; month = .January day = 1 &#125; //如果不重载此构造方法，将不能调用 Date(month: , day: ) init(month: Month, day: Int) &#123; self.month = month self.day = day &#125;&#125;let date = Date(month: .February, day: 14)let dateMonth = date.month // Februarylet dateDay = date.day // 14 Mutating methods结构体有个限制（因为结构体为值类型），其成员方法 method 不能改变其成员属性，除非用 mutating 修饰此 method 123456789struct Date &#123; var month: Month var day: Int //用 mutating 修饰，此方法才能修改属性 mutating func advance() &#123; day += 1 &#125;&#125; Type methods (静态方法)1234567struct Utils &#123; static func factorial(number: Int) -&gt; Int &#123; return (1...number).reduce(1, combine: *) &#125;&#125;let factorial = Utils.factorial(6) // 720 协议 (Protocols)定义协议1234567891011121314151617181920212223enum Direction &#123; case Left case Right &#125;protocol Vehicle &#123; //协议中不能设置任何 如 private, internal 或 public 的访问控制 //可以定义属性，但必须要标明 get, set，跟计算属性类似，但不能有任何实现 var weight: Int &#123; get &#125; var name: String &#123; get set &#125; func accelerate() func stop() //协议中不能有对于方法的任何实现代码 //故，不能写成 func turn(direction: Direction = .Left) func turn(direction: Direction) //如果要实现可选参数，则需要写重载的方法，如下： func turn() func description() -&gt; String&#125; 协议继承123456789protocol Vehicle &#123; func accelerate() func stop()&#125;//协议 WheeledVehicle 继承了协议 Vehicleprotocol WheeledVehicle: Vehicle &#123; var numberOfWheels: Int &#123; get &#125; var wheelSize: Double &#123; get set &#125;&#125; 实现协议协议可以被 类 , 结构体 , 枚举 来实现 12345678910111213141516171819202122232425262728293031323334protocol Wheeled &#123; var numberOfWheels: Int &#123; get &#125;&#125;//类class ClassyBike: Wheeled &#123; let numberOfWheels = 2&#125;//结构体struct StructyBike: Wheeled &#123; let numberOfWheels = 2&#125;//枚举enum EnummyBike: Wheeled &#123; case Mountain case Road case Tricycle var numberOfWheels: Int &#123; switch self &#123; case Mountain, Road: return 2 case Tricycle: return 3 &#125; &#125; &#125;// 类var wheels: Wheeled = ClassyBike()wheels.numberOfWheels // 2// 结构体wheels = StructyBike()wheels.numberOfWheels // 2// 枚举wheels = EnummyBike.Tricyclewheels.numberOfWheels // 3! 实现协议方法 123456789101112131415161718192021protocol Vehicle &#123; func accelerate() func stop()&#125;//类 Bike 实现了协议 Vehicleclass Bike: Vehicle &#123; var peddling: Bool = false var brakesApplied: Bool = false //实现协议所有方法 func accelerate() &#123; peddling = true brakesApplied = false &#125; func stop() &#123; peddling = false brakesApplied = true &#125;&#125; 实现协议属性 123456789101112131415161718192021222324252627282930313233343536protocol Vehicle &#123; func accelerate() func stop()&#125;protocol WheeledVehicle: Vehicle &#123; var numberOfWheels: Int &#123; get &#125; var wheelSize: Double &#123; get set &#125;&#125;//类 Bike 实现了协议 WheeledVehicleclass Bike: WheeledVehicle &#123; //用 计算属性 实现协议所有属性 var numberOfWheels: Int &#123; return 2 &#125; private var myWheelSize: Double = 16.0 var wheelSize: Double &#123; get &#123; return myWheelSize &#125; set &#123; myWheelSize = newValue &#125; &#125; &#125;//等价于class Bike: WheeledVehicle &#123; //不要求必须要用计算属性实现协议属性 //是要对于协议用 get 修饰的属性，继承后可以读；相应的对于协议用 set 修饰的属性，继承后可以写，即可。 let numberOfWheels = 2 //let 表明 只读 var wheelSize = 16.0 //var 表明可 读写&#125; 123456789101112131415161718192021222324protocol Vehicle &#123; func accelerate() func stop()&#125;protocol WheeledVehicle: Vehicle &#123; var numberOfWheels: Int &#123; get &#125; var wheelSize: Double &#123; get set &#125;&#125;class Bike: WheeledVehicle &#123; //虽然协议 WheeledVehicle 中表明只读，但此处可以用 var //用 var 表明对于类 Bike 可读写 var numberOfWheels = 2 var wheelSize = 16.0&#125;var bike: Bike = Bike()//可以读写bike.numberOfWheels = 16 // 16-wheeler!var wheeledBike: WheeledVehicle = bike// 此时不能给 wheeledBike 的 numberOfWheels 赋值，因为协议 WheeledVehicle 中 numberOfWheels 为 只读 Typealias1234567891011121314151617181920212223242526protocol WeightCalculatable &#123; //typealias 类型别名，它允许实现此协议的类（结构体或枚举）, 可以任意指定其实际类型 //typealias 也同时使协议 WeightCalculatable 不能用于声明变量 (因为编译器不知晓 WeightType 的实际类型), 仅能用于generic constraints(泛型约束) typealias WeightType func calculateWeight() -&gt; WeightType&#125;class HeavyThing: WeightCalculatable &#123; // HeavyThing 指定 WeightType 为 Int 类型 typealias WeightType = Int func calculateWeight() -&gt; Int &#123; return 100 &#125;&#125;class LightThing: WeightCalculatable &#123; // LightThing 指定 WeightType 为 Double 类型 typealias WeightType = Double func calculateWeight() -&gt; Double &#123; return 0.0025 &#125;&#125;// 协议 WeightCalculatable 不能用于声明变量，仅能用于generic constraints(泛型约束)let b: WeightCalculatable = LightThing() // Build error! Extensions12345678910111213141516171819202122232425262728293031protocol WhatType &#123; var typeName: String &#123; get &#125;&#125;//用 extension 扩展类型的协议，包括原始类型也可以扩展其协议//此特征可以允许你给你实际无法拥有和操作的类添加协议，扩展功能extension String: WhatType &#123; var typeName: String &#123; return \"I'm a String\" &#125;&#125;let myType: String = \"Swift Apprentice!\"myType.typeName // I'm a Stringclass Bike &#123; &#125;//用 extension 可以方便的添加类（结构体或枚举）的协议，增加其功能；也可以方便的删除其协议和功能(只需把整个 extension 删除即可)extension Bike: Wheeled &#123; //但 此特征 不能增加 存储属性(stored properties)，只能增加计算属性(computed properties) var numberOfWheels: Int &#123; return 2 &#125;&#125;extension Bike: Vehicle &#123; func accelerate() &#123; // Accelerate &#125; func stop() &#123; // Stop &#125; &#125; 操作符Extensions (Equatable和Comparable协议)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657struct Record &#123; var wins: Int var losses: Int&#125;/*swift 标准库中 Equatable 的定义protocol Equatable &#123; func ==(lhs: Self, rhs: Self) -&gt; Bool&#125;*/extension Record: Equatable &#123;&#125;//仅需实现 == ( != 会自动生成)func ==(lhs: Record, rhs: Record) -&gt; Bool &#123; return lhs.wins == rhs.wins &amp;&amp; lhs.losses == rhs.losses&#125;let recordA = Record(wins: 10, losses: 5)let recordB = Record(wins: 10, losses: 5)recordA == recordB // True/*swift 标准库中 Comparable 的定义protocol Comparable : Equatable &#123; func &lt;(lhs: Self, rhs: Self) -&gt; Bool func &lt;=(lhs: Self, rhs: Self) -&gt; Bool func &gt;=(lhs: Self, rhs: Self) -&gt; Bool func &gt;(lhs: Self, rhs: Self) -&gt; Bool&#125;*/extension Record: Comparable &#123;&#125;//仅需实现 &lt; ( &gt;,&lt;=,&gt;= 会自动生成)func &lt;(lhs: Record, rhs: Record) -&gt; Bool &#123; let lhsPercent = Double(lhs.wins) / (Double(lhs.wins) + Double(lhs.losses)) let rhsPercent = Double(rhs.wins) / (Double(rhs.wins) + Double(rhs.losses)) return lhsPercent &lt; rhsPercent&#125;let team1 = Record(wins: 23, losses: 8)let team2 = Record(wins: 23, losses: 8)let team3 = Record(wins: 14, losses: 11)team1 &lt; team2 // falseteam1 &gt; team3 // trueteam1 &gt;= team3 // trueteam1 &lt;= team3 // falselet leagueRecords = [team1, team2, team3]//既然 Record 实现了 Comparable 协议，自然可以使用 swift 标准库的相关函数进行排序等操作：leagueRecords.sort()// &#123;wins 14, losses 11&#125;// &#123;wins 23, losses 8&#125;// &#123;wins 23, losses 8&#125;leagueRecords.maxElement() // &#123;wins 23, losses 8&#125;leagueRecords.minElement() // &#123;wins 23, losses 8&#125;leagueRecords.startsWith([team1, team2]) // trueleagueRecords.contains(team1) // true Hashable协议当你的自定义类型要用于 Dictionary 的 key 或 Set 中的元素时，必须要实现 Hashable 协议。 1234567891011121314151617181920212223242526272829303132333435/*swift 标准库中 Hashable 的定义protocol Hashable : Equatable &#123; var hashValue: Int &#123; get &#125;&#125;*/class Student &#123; var studentId: Int var firstName: String var lastName: String init(studentId: Int, firstName: String, lastName: String) &#123; self.studentId = studentId self.firstName = firstName self.lastName = lastName &#125;&#125;//因为 Hashable 协议继承自 Equatable 协议，故，Student 需要实现 Equatable 协议extension Student: Equatable &#123;&#125;func ==(lhs: Student, rhs: Student) -&gt; Bool &#123; return lhs.studentId == rhs.studentId&#125;extension Student: Hashable &#123; //返回整数哈希值，用于区分不同 Student 实例 var hashValue: Int &#123; return studentId &#125;&#125;let john = Student(studentId:1, firstName: \"Johnny\", lastName: \"Appleseed\")// Dictionarylet lockerMap: [Student: String] = [john: \"14B\"]// Setlet classRoster: Set&lt;Student&gt; = [john, john, john, john]classRoster.count // 1 BooleanType 协议实现了 BooleanType 协议的自定义类型可以在判断条件中使用 因为 Swift 中几乎所有核心类型都是用结构体实现的，包括 Bool 类型，Bool 结构体也实现了 BooleanType 协议 12345678910111213141516171819202122/*swift 标准库中 Hashable 的定义protocol BooleanType &#123; var boolValue: Bool &#123; get &#125;&#125;*/struct Record &#123; var wins: Int var losses: Int&#125;extension Record: BooleanType &#123; var boolValue: Bool &#123; return wins &gt; losses &#125;&#125;if Record(wins: 10, losses: 5) &#123; print(\"winning!\")&#125; else &#123; print(\"losing :(\")&#125; CustomStringConvertibleCustomStringConvertible 协议 用于 debug 自定义类型时打印 log 12345678910111213141516171819202122232425/*swift 标准库中 Hashable 的定义protocol CustomStringConvertible &#123; var description: String &#123; get &#125;&#125;*/struct Record &#123; var wins: Int var losses: Int&#125;//默认let record = Record(wins: 23, losses: 8)print(record)// Record(wins: 23, losses: 8)//自定义extension Record: CustomStringConvertible &#123; var description: String &#123; return \"\\(wins) - \\(losses)\" &#125;&#125;print(record)// 23 - 8 面向协议编程 ( Protocol-Oriented Programming )扩展协议 (protocol extensions)12345678910111213141516171819202122232425protocol TeamRecord &#123; var wins: Int &#123; get &#125; var losses: Int &#123; get &#125; func winningPercentage() -&gt; Double&#125;//对协议进行扩展 (extension)//与协议不同，协议的扩展，可以有实现extension TeamRecord &#123; //计算属性 gamePlayed 及其实现 var gamesPlayed: Int &#123; return wins + losses &#125;&#125;//实现 TeamRecord 协议struct BaseballRecord: TeamRecord &#123; var wins: Int var losses: Int func winningPercentage() -&gt; Double &#123; return Double(wins) / (Double(wins) + Double(losses)) &#125;&#125;let sanFranciscoSwifts = BaseballRecord(wins: 10, losses: 5)//BaseballRecord 并不用实现 gamesPlayed 方法，而可以直接使用sanFranciscoSwifts.gamesPlayed // 15 协议中方法的默认实现 (Default implementations)1234567891011121314151617181920212223242526272829303132333435363738protocol TeamRecord &#123; var wins: Int &#123; get &#125; var losses: Int &#123; get &#125; func winningPercentage() -&gt; Double&#125;//用 extension 默认实现 winningPercentage//要实现 TeamRecord 接口，便可以不用实现 winningPercentage 方法。extension TeamRecord &#123; func winningPercentage() -&gt; Double &#123; return Double(wins) / (Double(wins) + Double(losses)) &#125;&#125;struct BaseballRecord: TeamRecord &#123; var wins: Int var losses: Int let seasonLength = 162&#125;struct BasketballRecord: TeamRecord &#123; var wins: Int var losses: Int let seasonLength = 82&#125;struct HockeyRecord: TeamRecord &#123; var wins: Int var losses: Int var ties: Int // HockeyRecord 引入 ties, 于是它可以有对 winningPercentage 方法 自己的实现 func winningPercentage() -&gt; Double &#123; return Double(wins) / (Double(wins) + Double(losses) + Double(ties)) &#125;&#125;let baseballRecord: TeamRecord = BaseballRecord(wins: 10, losses: 6)let hockeyRecord: TeamRecord = HockeyRecord(wins: 8, losses: 7, ties: 1)baseballRecord.winningPercentage() // 10/(10+6) == .625hockeyRecord.winningPercentage() // 8/(8+7+1) == .500 扩展协议的分派(dispatching) 协议 (protocol) 定义了，扩展 (extension) 中也定义重写了的方法或属性，无论以协议声明还是以实现类型声明，若实现类型实现了，则总是调用实现类型中的方法或属性，否则调用扩展，参考 协议中方法的默认实现。 协议 (protocol) 未定义了，扩展 (extension) 中定义实现的方法或属性，则依赖声明的是协议还是实现类型，若以协议声明则调用协议中的方法或属性，若以实现类型声明则调用实现类中的方法或属性 (假如实现类型实现了此方法或属性)，如下： 123456789101112131415161718192021222324252627protocol TeamRecord &#123; var wins: Int &#123; get &#125; var losses: Int &#123; get &#125; func winningPercentage() -&gt; Double&#125;extension TeamRecord &#123; var gamesPlayed: Int &#123; return wins + losses &#125;&#125;struct BaseballRecord: TeamRecord &#123; var wins: Int var losses: Int let gamesPlayed: Int = 162 func winningPercentage() -&gt; Double &#123; return Double(wins) / (Double(wins) + Double(losses)) &#125;&#125;// 以 TeamRecord 协议定义let team1: TeamRecord = BaseballRecord(wins: 10, losses: 5)// 以 BaseballRecord 类 定义let team2: BaseballRecord = BaseballRecord(wins: 10, losses: 5)// 调用的是 TeamRecord extension 里的gamesPlayedteam1.gamesPlayed // 15// 调用的是 BaseballRecord 里的gamesPlayedteam2.gamesPlayed // 162!! 限制类型的协议扩展 (Type constraints)12345678910111213141516171819202122protocol TeamRecord &#123; var wins: Int &#123; get &#125; var losses: Int &#123; get &#125; func winningPercentage() -&gt; Double&#125;protocol Tieable &#123; var ties: Int &#123; get &#125;&#125;//当实现类型既实现了 TeamRecord 又实现了 Tieable 才予以扩展extension TeamRecord where Self: Tieable &#123; func winningPercentage() -&gt; Double &#123; return Double(wins) / (Double(wins) + Double(losses) + Double(ties)) &#125;&#125;struct HockeyRecord: TeamRecord, Tieable &#123; var wins: Int var losses: Int var ties: Int&#125;let hockeyRecord: TeamRecord = HockeyRecord(wins: 8, losses: 7, ties: 1)hockeyRecord.winningPercentage() // 0.5 Traits, mixins and multiple inheritance123456789101112131415161718192021222324252627282930313233343536373839404142434445464748protocol TeamRecord &#123; var wins: Int &#123; get &#125; var losses: Int &#123; get &#125; func winningPercentage() -&gt; Double&#125;extension TeamRecord &#123; func winningPercentage() -&gt; Double &#123; return Double(wins) / (Double(wins) + Double(losses)) &#125;&#125;protocol TieableRecord &#123; var ties: Int &#123; get &#125;&#125;protocol DivisionalRecord &#123; var divisionalWins: Int &#123; get &#125; var divisionalLosses: Int &#123; get &#125;&#125;//Trait，增加了计算 totalPoints 的功能protocol PointableRecord &#123; func totalPoints() -&gt; Int&#125;extension PointableRecord where Self: TieableRecord, Self: TeamRecord &#123; func totalPoints() -&gt; Int &#123; return (2 * wins) + (1 * ties) &#125;&#125;//mixins: CustomStringConvertible, Equatable struct HockeyRecord: TeamRecord, TieableRecord, DivisionalRecord, CustomStringConvertible, Equatable &#123; var wins: Int var losses: Int var ties: Int var divisionalWins: Int var divisionalLosses: Int var description: String &#123; return \"\\(wins) - \\(losses) - \\(ties)\" &#125;&#125;func ==(lhs: HockeyRecord, rhs: HockeyRecord) -&gt; Bool &#123; return lhs.wins == rhs.wins &amp;&amp; lhs.ties == rhs.ties &amp;&amp; lhs.losses == rhs.losses&#125; 高级错误处理1234567891011121314151617181920212223242526272829303132333435363738//ErrorType 协议enum RollingError: ErrorType &#123; case Doubles case OutOfFunding&#125;var hasFunding = true//throwsfunc roll(firstDice: Int, secondDice: Int) throws &#123; let error: RollingError if firstDice == secondDice &amp;&amp; hasFunding &#123; error = .Doubles hasFunding = false throw error &#125; else if firstDice == secondDice &amp;&amp; !hasFunding &#123; hasFunding = true print(\"Huzzah! You raise another round of funding!\") &#125; else if !hasFunding &#123; error = .OutOfFunding throw error&#125; else &#123; print(\"You moved \\(firstDice + secondDice) spaces\") &#125;&#125;//try catchfunc move(firstDice: Int, secondDice: Int) -&gt; String &#123; do &#123; try roll(firstDice, secondDice: secondDice) return \"Successful roll.\" &#125; catch RollingError.Doubles &#123; return \"You rolled doubles and have lost your funding\" &#125; catch RollingError.OutOfFunding &#123; return \"You need to do another round of funding.\" &#125; catch &#123; return \"Unknown error\" &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102enum Direction &#123; case Left case Right case Forward&#125;enum PugBotError: ErrorType &#123; case DidNotTurnLeft(directionMoved: Direction) case DidNotTurnRight(directionMoved: Direction) case DidNotGoForward(directionMoved: Direction) case EndOfPath&#125;class PugBot &#123; let name: String let correctPath: [Direction] var currentStepInPath = 0 //可失败的初始化(failable initializer) init? (name: String, correctPath: [Direction]) &#123; self.correctPath = correctPath self.name = name guard (correctPath.count &gt; 0) else &#123;return nil&#125; switch name &#123; case \"Delia\", \"Olive\", \"Frank\", \"Otis\", \"Doug\": break default: return nil &#125; &#125; func turnLeft() throws &#123; guard (currentStepInPath &lt; correctPath.count) else &#123; throw PugBotError.EndOfPath &#125; let direction = correctPath[currentStepInPath] if direction != .Left &#123; throw PugBotError.DidNotTurnLeft(directionMoved: direction) &#125; currentStepInPath += 1 &#125; func turnRight() throws &#123; guard (currentStepInPath &lt; correctPath.count) else &#123; throw PugBotError.EndOfPath &#125; let direction = correctPath[currentStepInPath] if direction != .Right &#123; throw PugBotError.DidNotTurnRight(directionMoved: direction) &#125; currentStepInPath += 1 &#125; func moveForward() throws &#123; guard (currentStepInPath &lt; correctPath.count) else &#123; throw PugBotError.EndOfPath &#125; let direction = correctPath[currentStepInPath] if direction != .Forward &#123; throw PugBotError.DidNotGoForward(directionMoved: direction) &#125; currentStepInPath += 1 &#125; func goHome() throws &#123; try moveForward() try turnLeft() try moveForward() try turnRight() &#125;&#125;func movePugBotSafely(move: () throws -&gt; ()) -&gt; String &#123; do &#123; try move() return \"Completed move successfully.\" &#125; catch PugBotError.DidNotTurnLeft(let directionMoved) &#123; return \"The PugBot was supposed to turn left, but turned \\(directionMoved) instead.\" &#125; catch PugBotError.DidNotTurnRight(let directionMoved) &#123; return \"The PugBot was supposed to turn right, but turned \\(directionMoved) instead.\" &#125; catch PugBotError.DidNotGoForward(let directionMoved) &#123; return \"The PugBot was supposed to move forward, but turned \\(directionMoved) instead.\" &#125; catch PugBotError.EndOfPath() &#123; return \"The PugBot tried to move past the end of the path.\" &#125; catch &#123; return \"An unknown error occurred\" &#125;&#125;let rightDirections: [Direction] = [.Forward, .Left, .Forward, .Right]let wrongDirections: [Direction] = [.Left, .Left, .Left, .Forward] let invalidPug = PugBot(name: \"Lassie\", correctPath: rightDirections)let myPugBot = PugBot(name: \"Delia\", correctPath: rightDirections)!let wrongPugBot = PugBot(name: \"Delia\", correctPath: wrongDirections)!movePugBotSafely &#123; try myPugBot.goHome() try myPugBot.moveForward()&#125;//&gt; The PugBot tried to move past the end of the path. 泛型 (Generics)123456789101112131415161718192021222324252627282930313233343536373839404142434445struct Cat &#123; var name: String&#125;struct Dog &#123; var name: String&#125;struct Keeper&lt;T&gt; &#123; var name: String var morningAnimal: T var afternoonAnimal: T&#125;let jason = Keeper(name: \"Jason\", morningAnimal: Cat(name: \"Whiskers\"), afternoonAnimal: Cat(name: \"Sleepy\"))//Swift 的类型推断//Arraylet favoriteIntsInferred = Array(arrayLiteral: 8, 9, 42)let favoriteFloatsInferred = Array&lt;Float&gt;(arrayLiteral: 8, 9, 42)let favoriteIntsExplicit2: Array&lt;Int&gt; = [8, 9, 42]let favoriteIntsInferred2: Array = [8, 9, 42]let favoriteFloatsInferred2: Array&lt;Float&gt; = [8, 9, 42]//Dictionarylet intNames: Dictionary&lt;Int, String&gt; = [42: \"forty-two\"] let intNames2: [Int: String] = [42: \"forty-two\", 7: \"seven\"]let intNames3 = [42: \"forty-two\", 7: \"seven\"]//Optionalvar birthdate: Optional&lt;NSDate&gt; = Optional&lt;NSDate&gt;.Noneif birthdate == Optional&lt;NSDate&gt;.None &#123; // no birthdate&#125;//等价于var birthdate: NSDate? = nilif birthdate == nil &#123; // no birthdate&#125;//泛型函数func swapped&lt;T, U&gt;(x: T, _ y: U) -&gt; (U, T) &#123; return (y, x)&#125;swapped(33, \"Jay\") // returns (\"Jay\", 33) 函数式编程12345678910111213141516171819202122232425262728293031323334353637import Foundation//maplet animals = [\"cat\", \"dog\", \"sheep\", \"dolphin\", \"tiger\"]func capitalize(s: String) -&gt; String &#123; return s.uppercaseString&#125;func characterForCharacterName(c: String) -&gt; Character &#123; let curlyBracedCharacterName = \"\\\\N&#123;\\(c)&#125;\" let charStr = curlyBracedCharacterName.stringByApplyingTransform( NSStringTransformToUnicodeName, reverse: true) return charStr!.characters.first!&#125;let uppercaseAnimals = animals.map(capitalize)let animalEmojis = uppercaseAnimals.map(characterForCharacterName)let uppercaseAnimals4 = animals.map(&#123; $0.uppercaseString &#125;)//filterlet threeCharacterAnimals = animals.filter() &#123; $0.characters.count == 3&#125;threeCharacterAnimals // =&gt; [\"cat\", \"dog\"]//reducefunc sum(items: [Int]) -&gt; Int &#123; return items.reduce(0, combine: +)&#125;let total = sum([1, 2, 3])total // =&gt; (((0 + 1) + 2) + 3) == 6func concatenate(items: [String]) -&gt; String &#123; return items.reduce(\"\", combine: +)&#125;let phrase = concatenate([\"Hello\",\" \",\"World\"])phrase // =&gt; (((\"\" + \"Hello\") + \" \") + \"World\") == \"Hello World\"","tags":[{"name":"swift","slug":"swift","permalink":"https://coderdotcool.github.io/tags/swift/"}]},{"title":"Git笔记","date":"2016-05-19T07:01:27.000Z","path":"Notes/Git笔记.html","text":"经常会忘git的一些命令，就整理了此份笔记供以后查找方便，会持续更新… 初级git init初始化一个空仓库 1git init git config配置「用户名」和「邮箱」 1234git config --global user.name \"docoder\"git config --global user.email \"docoder@163.com\"git config —listgit config user.email git help1git help commit git status untracked : 新增的文件，Git 不知道它的存在 not staged : 被索引过又被修改了的文件 staged : 通过 git add 后被即将被提交的文件 1git status git log123git loggit log --onelinegit log --oneline --decorate .gitignore用 ! 来对模式取反 12*.a!lib.a git add1234git add READMEgit add --all .git add .git add -A git tag12345678910git tag new_taggit tag -d deleteTag#git push 命令默认是不会 push Tags 的，需要加参数。git push --tags#添加远程 Tag 0.0.2git push origin 0.0.2#删除远程 Tag 0.0.1git push origin :0.0.1 git rm1234git rm deleteme.js#从 staging area 中移除出来，但不删除文件git rm deleteme.js --cached git mv12git mv oldfile.txt newfile.txtgit mv *.html src/ git merge1git merge feature_branch git commit123456789git commit -m \"Add README\"git commit .git commit -agit commit -am \"This is our first commit\"#追加提交git commit --amend#修改提交日期git commit -m \"Commit your changes with the future date\" --date '2018-04-05 23:59:59' git branch123456789git branch test_branchgit checkout -b my_branch#删除分支git branch -d delete_branch#有时忘记开新的分支，就修改并提交了代码。开分支的时候默认是基于最新的一次提交的，但我们也可以指定参数使其基于任一次提交。git branch test_branch HEAD~1 git remoteremote 对应远端仓库 1234git remote add origin https://github.com/docoder/docoder.github.iogit remotegit remote -vgit remote rm origin git clone12git clone https://github.com/docoder/docoder.github.iogit clone https://github.com/docoder/docoder.github.io myname.github.io git checkout123456789git checkout config.jsgit checkout -b my_branch#checkout tag 和分支没有什么区别git checkout v1.2#当存在同名的 tag 和分支时,分支优先级高，所以要显式地告诉 git 我们是要切换到 taggit checkout tags/v1.2 git fetch12#用 fetch 命令把代码拿下来,但并不合并到本地仓库git fetch origin git pull将别人提交的代码，拉到本地 1git pull origin master git diff1git diff git push12#把分支 push 到远程仓库中去git push origin test_branch git reset12345git reset to_commit_second.js#`HEAD~1` 倒数第二的位置#`--soft` 把变更保持在 staging areagit reset HEAD~1 --soft 高级git stash把当前未提交的改动「复制」到另一个地方暂存起来，待要恢复的时候执行 git stash pop 即可 12git stashgit stash pop git add12# Open the diff vs. the index in an editor and let the user edit it. After the editor was closed, adjust the hunk headers and apply the patch to the index.git add -e git merge12345678910111213#将long-feature-branch的所有commit 合成一个commit 到本分支git merge long-feature-branch --squash git commit #解决冲突git merge mybranch #(CONFLICT (content): Merge conflict in poem.txt) vim poem.txt #(解决冲突的地方为你想要的正确的代码) git add poem.txt git commit #(可以修改message也可以不修改，保存) git rebase123456789101112131415161718192021222324252627282930git rebase#将feature分支rebase到master上git rebase master feature#修改 commit messagegit rebase -i HEAD~~ #(将要修改的commit的前面的 pick 改成 edit 后保存) git commit --amend #(修改 commit message 后保存) git rebase --continue #合并commitgit rebase -i HEAD~4 #(将要合并的commit的前面的 pick 都改成 squash 后保存 ) #(可以修改message也可以不修改，保存)#拆分commitgit rebase -i HEAD^ #(将`updated README formatting and added blame`拆分为：第一次为 `updated README formatting`，第二次为 `added blame`) #(将要拆分的commit的前面的 pick 改成 edit 后保存 ) git add README git commit -m 'updated README formatting' git add lib/simplegit.js git commit -m 'added blame' git rebase --continue#调整commit的顺序git rebase -i HEAD~3 #(将 pick 的 commit 和其 message 的顺序改成你的要求，后保存) git cherry-pick12#将其他分支的提交（ca32a6d）拿过来到本分支git cherry-pick ca32a6d git revert1234567#撤销 某次操作，此次操作之前和之后的commit和history都会保留，并且把这次撤销作为一次最新的提交#撤销前一次 commitgit revert HEAD#撤销前前一次 commitgit revert HEAD^#撤销指定的commit，撤销也会作为一次提交进行保存git revert 7ab60ed git grep1234567891011121314151617181920212223#查找每个包含有字符串`searchStr`的地方git grep searchStr#`-n` 显示行号git grep -n searchStr#`--name-only` 只显示文件名git grep --name-only searchStr#查找仓库里某个特定版本(标签名tag reference:`v1.5.0`)里的内容git grep searchStr v1.5.0#`-c` 查看每个文件里有多少行匹配的内容 (统计每个文件有多少的TODO)git grep -c TODO #哪个地方定义了宏(`#define`):`SORT_DIRENT`git grep -e '#define' --and -e SORT_DIRENT#名字中含有`PATH`或是`MAX`的宏(`#define`)定义git grep -e '#define' --and \\( -e PATH -e MAX \\)#哪个地方含有`MAX`或是`MIN`git grep --all-match -e MAX -e MIN git reflog12345git reflog#Restore the deleted commitgit reflog git reset --hard 18cbf98 git submodule1git submodule add https://github.com/jackmaney/githug-include-me ./githug-include-me git blame快速找到某行代码最后的修改者,追责 1git blame config.js git repack12#Optimise how your repository is packaged ensuring that redundant packs are removed.git repack -d git bisectBisect 就是利用二分查找发来查找在你的某一分支中到底是哪一次提交引入了特定的变更(通常为检测bug) 首先，要用方法检测出一个给定的提交点是不是有 bug，可以写个测试代码或脚本 1234567891011121314151617181920#开始 bisectgit bisect start#没有得到想要的结果（就是没有任何输出），所以我们把它标记为坏的，作为终点。git bisect bad#指定一个好的提交点：假设第一个提交点（80a9b3d）是没有 bug 的，作为起点。git bisect good 80a9b3d#运行自动化脚本 `test.sh` git bisect run ./test.sh#或 运行make脚本 `test` git bisect run make test#(脚本，正确的返回 0，反之返回 1)#如：test.sh:if [[ `grep 1013 file.txt` ]]; then exit 1else exit 0fi git filter-branch12345678910111213#让trunk子目录成为每一次提交的新的项目根目录$ git filter-branch --subdirectory-filter trunk HEAD#全局性地更换电子邮件地址git filter-branch --commit-filter ' if [ \"$GIT_AUTHOR_EMAIL\" = \"schacon@localhost\" ]; then GIT_AUTHOR_NAME=\"Scott Chacon\"; GIT_AUTHOR_EMAIL=\"schacon@example.com\"; git commit-tree \"$@\"; else git commit-tree \"$@\"; fi' HEAD","tags":[{"name":"git","slug":"git","permalink":"https://coderdotcool.github.io/tags/git/"}]}]